<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hand‚ÄëDraw ‚Äî Camera Hand Tracking Canvas</title>
  <style>
    :root{
      --bg:#0b0e14; --panel:#151a22; --muted:#7a8599; --txt:#e6edf3; --accent:#6ee7ff; --accent2:#a78bfa;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:1fr;}
    canvas#draw{position:absolute;inset:0;touch-action:none}
    canvas#overlay{position:absolute;inset:0;pointer-events:none}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;opacity:.0;transition:opacity .3s}
    .video-visible video{opacity:.35;mix-blend-mode:luminosity}

    /* Toolbar */
    .toolbar{position:fixed;left:16px;top:16px;display:flex;gap:10px;align-items:center;background:linear-gradient(180deg,#171c26,#0f1320);border:1px solid #232b3a;padding:10px;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);backdrop-filter:blur(6px)}
    .btn{display:inline-flex;align-items:center;gap:8px;border:1px solid #2a3244;background:#111523;color:#cbd5e1;padding:8px 10px;border-radius:12px;cursor:pointer;transition:.15s}
    .btn:hover{border-color:#3b465e;color:#fff}
    .btn[aria-pressed="true"]{background:#1a2030;border-color:#556384;color:#fff}
    .swatch{width:22px;height:22px;border-radius:50%;border:2px solid #111;box-shadow:inset 0 0 0 2px rgba(255,255,255,.15)}
    .row{display:flex;align-items:center;gap:10px}
    label{color:#aab4c4;font-size:12px}
    input[type="range"]{width:140px}
    .spacer{width:10px}

    /* Toast/help */
    .hud{position:fixed;right:16px;top:16px;display:flex;flex-direction:column;gap:8px;max-width:min(36ch,48vw)}
    .toast{background:linear-gradient(180deg,#111827,#0b1020);border:1px solid #253048;border-radius:14px;padding:10px 12px;color:#cbd5e1}
    .toast small{color:#93a2b9}

    /* Mobile tweaks */
    @media(max-width:740px){
      .toolbar{left:10px;right:10px;flex-wrap:wrap;gap:8px}
      input[type="range"]{width:110px}
    }
  </style>
</head>
<body>
  <div id="app">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="draw"></canvas>
    <canvas id="overlay"></canvas>
  </div>

  <!-- Minimal Toolbar -->
  <div class="toolbar" role="toolbar" aria-label="Drawing Tools">
    <button id="cameraBtn" class="btn" title="Toggle camera background" aria-pressed="false">üì∑ Camera</button>
    <button id="landmarkBtn" class="btn" title="Toggle hand landmarks" aria-pressed="true">üñêÔ∏è Landmarks</button>
    <div class="spacer"></div>
    <button id="penBtn" class="btn" aria-pressed="true" title="Pen tool (pinch index+thumb to draw)">‚úèÔ∏è Pen</button>
    <button id="eraserBtn" class="btn" aria-pressed="false" title="Eraser tool (or pinch middle+thumb to erase temporarily)">ü©π Eraser</button>
    <div class="row">
      <label for="size">Size</label>
      <input id="size" type="range" min="1" max="60" value="8" />
    </div>
    <div class="row">
      <label for="color">Color</label>
      <input id="color" type="color" value="#ffde59" />
      <button id="paletteBtn" class="btn" title="Cycle palette">üé®</button>
    </div>
    <button id="undoBtn" class="btn" title="Undo (Z)">‚Ü∂ Undo</button>
    <button id="redoBtn" class="btn" title="Redo (Y)">‚Ü∑ Redo</button>
    <button id="clearBtn" class="btn" title="Clear">üóëÔ∏è Clear</button>
    <button id="saveBtn" class="btn" title="Save PNG">üíæ Save</button>
  </div>

  <div class="hud" aria-live="polite">
    <div class="toast">
      <strong>Gestures</strong><br/>
      <small>‚Ä¢ Pinch <b>index‚Äìthumb</b> to draw ‚Ä¢ Pinch <b>middle‚Äìthumb</b> to erase (momentary) ‚Ä¢ Open palm to stop ‚Ä¢ Use toolbar for precise control</small>
    </div>
    <div id="status" class="toast"><small>Loading hand model‚Ä¶</small></div>
  </div>

  <script type="module">
    // ===== Mediapipe Tasks: Hand Landmarker =====
    import { HandLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/vision_bundle.mjs';

    const video = document.getElementById('video');
    const draw = document.getElementById('draw');
    const overlay = document.getElementById('overlay');
    const ctx = draw.getContext('2d');
    const octx = overlay.getContext('2d');

    const ui = {
      cameraBtn: document.getElementById('cameraBtn'),
      landmarkBtn: document.getElementById('landmarkBtn'),
      penBtn: document.getElementById('penBtn'),
      eraserBtn: document.getElementById('eraserBtn'),
      size: document.getElementById('size'),
      color: document.getElementById('color'),
      paletteBtn: document.getElementById('paletteBtn'),
      undoBtn: document.getElementById('undoBtn'),
      redoBtn: document.getElementById('redoBtn'),
      clearBtn: document.getElementById('clearBtn'),
      saveBtn: document.getElementById('saveBtn'),
      status: document.getElementById('status')
    };

    const PALETTE = ['#ffde59','#ff6b6b','#9aff7a','#6ee7ff','#a78bfa','#ffffff','#111827'];
    let paletteIndex = 0;

    // Drawing state
    let tool = 'pen'; // 'pen' | 'eraser'
    let brushColor = ui.color.value;
    let brushSize = +ui.size.value;

    // Undo/Redo stacks
    const undoStack = []; const redoStack = []; const MAX_STACK = 30;
    const snapshot = () => { redoStack.length = 0; if (undoStack.length >= MAX_STACK) undoStack.shift(); undoStack.push(draw.toDataURL('image/png')); };
    const restore = (dataURL) => new Promise((res)=>{ const i=new Image(); i.onload=()=>{ ctx.clearRect(0,0,draw.width,draw.height); ctx.drawImage(i,0,0,draw.width,draw.height); res(); }; i.src=dataURL; });

    ui.undoBtn.addEventListener('click', async ()=>{ if (!undoStack.length) return; const cur = draw.toDataURL('image/png'); const prev = undoStack.pop(); redoStack.push(cur); await restore(prev); });
    ui.redoBtn.addEventListener('click', async ()=>{ if (!redoStack.length) return; const cur = draw.toDataURL('image/png'); const nxt = redoStack.pop(); undoStack.push(cur); await restore(nxt); });

    ui.clearBtn.addEventListener('click', ()=>{ snapshot(); ctx.clearRect(0,0,draw.width,draw.height); });
    ui.saveBtn.addEventListener('click', ()=>{ const a=document.createElement('a'); a.download=`hand-draw-${Date.now()}.png`; a.href=draw.toDataURL('image/png'); a.click(); });

    ui.penBtn.addEventListener('click', ()=> setTool('pen'));
    ui.eraserBtn.addEventListener('click', ()=> setTool('eraser'));
    ui.paletteBtn.addEventListener('click', ()=>{ paletteIndex=(paletteIndex+1)%PALETTE.length; ui.color.value=PALETTE[paletteIndex]; brushColor = ui.color.value; });

    ui.color.addEventListener('input', e=> brushColor = e.target.value);
    ui.size.addEventListener('input', e=> brushSize = +e.target.value);

    ui.cameraBtn.addEventListener('click', ()=>{
      const on = document.body.classList.toggle('video-visible');
      ui.cameraBtn.setAttribute('aria-pressed', on ? 'true':'false');
    });
    ui.landmarkBtn.addEventListener('click', ()=>{
      showLandmarks = !showLandmarks; ui.landmarkBtn.setAttribute('aria-pressed', showLandmarks? 'true':'false');
    });

    function setTool(next){ tool = next; ui.penBtn.setAttribute('aria-pressed', next==='pen'); ui.eraserBtn.setAttribute('aria-pressed', next==='eraser'); }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase()==='z') ui.undoBtn.click();
      if (e.key.toLowerCase()==='y') ui.redoBtn.click();
      if (e.key==='1') setTool('pen');
      if (e.key==='2') setTool('eraser');
    });

    // Resize canvases
    const resize = ()=>{
      const {clientWidth:w, clientHeight:h} = document.body;
      for (const c of [draw, overlay]){ const img = c===draw ? ctx.getImageData(0,0,c.width||1,c.height||1):null; c.width=w; c.height=h; if (img && img.width && img.height){ ctx.putImageData(img, 0, 0); }
      }
    };
    new ResizeObserver(resize).observe(document.body);
    resize();

    // Camera
    async function initCamera(){
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user', width:{ideal:1280}, height:{ideal:720} }, audio:false });
      video.srcObject = stream; await video.play();
    }

    // Hand tracking
    let handLandmarker = null;
    let showLandmarks = true;

    async function initHands(){
      const filesetResolver = await FilesetResolver.forVisionTasks(
        // CDN root for wasm assets
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm'
      );
      // Try multiple model URLs (latest first) to avoid CDN 404s
      const MODEL_URLS = [
        'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task',
        'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task'
      ];
      let lastErr = null;
      for (const modelAssetPath of MODEL_URLS){
        try{
          handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
            baseOptions: { modelAssetPath },
            numHands: 2,
            runningMode: 'VIDEO',
            minHandDetectionConfidence: 0.5,
            minHandPresenceConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
          ui.status.innerHTML = `<small>Loaded model: ${modelAssetPath.includes('/latest/') ? 'latest' : 'v1'}</small>`;
          break;
        }catch(e){ lastErr = e; }
      }
      if (!handLandmarker){ throw new Error(`Failed to load hand model. Last error: ${lastErr && lastErr.message || lastErr}`); }
    }

    // Utility: distance between two landmarks
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    // Drawing helpers
    let isDrawing = false;
    let lastX = 0, lastY = 0;
    let lastMode = 'pen'; // or 'erase'

    function drawLine(x,y, mode){
      if (!isDrawing){
        isDrawing = true; lastX=x; lastY=y; snapshot();
        return;
      }
      ctx.save();
      ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.lineWidth = brushSize;
      if (mode==='erase' || tool==='eraser'){
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)';
      } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = brushColor;
      }
      ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); ctx.restore();
      lastX=x; lastY=y; lastMode = mode;
    }

    function endStroke(){ if (isDrawing){ isDrawing=false; } }

    // Main loop
    let lastVideoTime = -1;
    let rafId = 0;

    async function loop(){
      if (!handLandmarker || video.readyState < 2){ rafId = requestAnimationFrame(loop); return; }
      const now = performance.now();
      if (video.currentTime !== lastVideoTime){
        lastVideoTime = video.currentTime;
        const res = handLandmarker.detectForVideo(video, now);
        renderOverlay(res);
        handleGestures(res);
      }
      rafId = requestAnimationFrame(loop);
    }

    function normToScreen(pt){ return { x: pt.x * overlay.width, y: pt.y * overlay.height } }

    function renderOverlay(res){
      octx.clearRect(0,0,overlay.width,overlay.height);
      if (!showLandmarks) return;
      if (!res || !res.landmarks) return;
      for (const lm of res.landmarks){
        // Draw skeleton
        octx.save();
        octx.lineWidth=2; octx.strokeStyle='rgba(110,231,255,.8)';
        const IDX = {WRIST:0, THUMB_TIP:4, INDEX_TIP:8, MIDDLE_TIP:12, RING_TIP:16, PINKY_TIP:20};
        const tips=[IDX.THUMB_TIP,IDX.INDEX_TIP,IDX.MIDDLE_TIP,IDX.RING_TIP,IDX.PINKY_TIP];
        for (const i of tips){ const p=normToScreen(lm[i]); octx.beginPath(); octx.arc(p.x,p.y,4,0,Math.PI*2); octx.fillStyle='rgba(167,139,250,.9)'; octx.fill(); }
        octx.restore();
      }
    }

    function handleGestures(res){
      if (!res || !res.landmarks || res.landmarks.length===0){ endStroke(); return; }
      const hand = res.landmarks[0]; // use first detected hand
      const IDX = {WRIST:0, THUMB_TIP:4, INDEX_TIP:8, MIDDLE_TIP:12, RING_TIP:16, PINKY_TIP:20, INDEX_MCP:5, PINKY_MCP:17};

      // Scale threshold by hand size
      const base = dist(hand[IDX.INDEX_MCP], hand[IDX.PINKY_MCP]);
      const pinchThresh = Math.max(0.035, base*0.22);

      const dIndex = dist(hand[IDX.THUMB_TIP], hand[IDX.INDEX_TIP]);
      const dMiddle = dist(hand[IDX.THUMB_TIP], hand[IDX.MIDDLE_TIP]);

      const pinchIndex = dIndex < pinchThresh;        // draw
      const pinchMiddle = dMiddle < pinchThresh*0.95; // erase (momentary)

      // Use index finger tip as brush point
      const tip = normToScreen(hand[IDX.INDEX_TIP]);

      // Simple open-palm stopper: if neither pinch active and distances are large => stop
      if (!pinchIndex && !pinchMiddle){ endStroke(); return; }

      const mode = pinchMiddle ? 'erase' : 'pen';
      drawLine(tip.x, tip.y, mode);
    }

    // Boot
    (async ()=>{
      try{
        await initCamera();
        await initHands();
        document.body.classList.add('video-visible');
        ui.cameraBtn.setAttribute('aria-pressed','true');
        ui.status.innerHTML = '<small>Model loaded. Show: index‚Äìthumb to draw, middle‚Äìthumb to erase.</small>';
        loop();
      }catch(err){
        console.error(err);
        ui.status.innerHTML = `<small style="color:#ff8a8a">${(err && err.message) || err}</small>`;
      }
    })();
  </script>
</body>
</html>
